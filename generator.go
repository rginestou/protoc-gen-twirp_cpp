package main

import (
	"bytes"
	"path"
	"strings"

	"protoc-gen-twirp_cpp/gen"
	"protoc-gen-twirp_cpp/gen/stringutils"
	"protoc-gen-twirp_cpp/gen/typemap"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

type twirp struct {
	reg *typemap.Registry

	importPrefix string            // String to prefix to imported package file names.
	importMap    map[string]string // Mapping from .proto file name to import path.

	// Package output:
	sourceRelativePaths bool // instruction on where to write output files

	// List of files that were inputs to the generator. We need to hold this in
	// the struct so we can write a header for the file that lists its inputs.
	genFiles []*descriptor.FileDescriptorProto

	// Output buffer that holds the bytes we want to write out for a single file.
	// Gets reset after working on a file.
	output *bytes.Buffer
}

func newGenerator() *twirp {
	t := &twirp{
		importMap: make(map[string]string),
		output:    bytes.NewBuffer(nil),
	}

	return t
}

func (t *twirp) Generate(in *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	params, err := parseCommandLineParams(in.GetParameter())
	if err != nil {
		gen.Fail("could not parse parameters passed to --twirp_out", err.Error())
	}

	t.importPrefix = params.importPrefix
	t.importMap = params.importMap

	t.genFiles = gen.FilesToGenerate(in)

	t.sourceRelativePaths = params.paths == "source_relative"

	// Collect information on types.
	t.reg = typemap.New(in.ProtoFile)

	// Showtime! Generate the response.
	resp := new(plugin.CodeGeneratorResponse)
	for _, f := range t.genFiles {
		respFile := t.generate(f)
		if respFile != nil {
			resp.File = append(resp.File, respFile)
		}
	}

	// Generate hpp lib
	resp.File = append(resp.File, generateJSONFile())
	resp.File = append(resp.File, generateHTTPFile())

	return resp
}

func (t *twirp) generate(file *descriptor.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	resp := new(plugin.CodeGeneratorResponse_File)
	if len(file.Service) == 0 {
		return nil
	}

	t.generateFileHeader(file)

	// For each service, generate client stubs
	for i, service := range file.Service {
		t.generateService(file, service, i)
	}

	t.generateFileFooter(file)

	resp.Name = proto.String(getFileName(file) + ".twirp.hpp")
	resp.Content = proto.String(t.output.String())
	t.output.Reset()

	return resp
}

func getFileName(file *descriptor.FileDescriptorProto) string {
	name := *file.Name
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}

	return name
}

func generateJSONFile() *plugin.CodeGeneratorResponse_File {
	resp := new(plugin.CodeGeneratorResponse_File)

	resp.Name = proto.String("json.hpp")
	resp.Content = proto.String(jsonFileContent)

	return resp
}

func generateHTTPFile() *plugin.CodeGeneratorResponse_File {
	resp := new(plugin.CodeGeneratorResponse_File)

	resp.Name = proto.String("http.hpp")
	resp.Content = proto.String(httpFileContent)

	return resp
}

func (t *twirp) generateFileHeader(file *descriptor.FileDescriptorProto) {
	t.P("// Code generated by protoc-gen-twirp_cpp ", gen.Version, ", DO NOT EDIT.")
	t.P("#ifndef CLIENT_", getFileName(file))
	t.P("#define CLIENT_", getFileName(file))
	t.P(`
#include "http.hpp"
#include "json.hpp"`)
	t.P(`#include "`, getFileName(file), `.pb.h"`)
	t.P(`#include <iostream>
#include <string>

using json::JSON;
using std::string;`)
	t.P(`namespace `, file.GetPackage(), ` {`)
}

func (t *twirp) generateFileFooter(file *descriptor.FileDescriptorProto) {
	t.P(`}

#endif`)
}

// P forwards to g.gen.P, which prints output.
func (t *twirp) P(args ...string) {
	for _, v := range args {
		t.output.WriteString(v)
	}
	t.output.WriteByte('\n')
}

// Big header comments to makes it easier to visually parse a generated file.
func (t *twirp) sectionComment(sectionTitle string) {
	t.P()
	t.P(`// `, strings.Repeat("=", len(sectionTitle)))
	t.P(`// `, sectionTitle)
	t.P(`// `, strings.Repeat("=", len(sectionTitle)))
	t.P()
}

func (t *twirp) generateService(file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto, index int) {
	servName := serviceName(service)

	t.sectionComment(servName + ` JSON Client`)
	t.generateClient("JSON", file, service)
}

// valid names: 'JSON', 'Protobuf'
func (t *twirp) generateClient(name string, file *descriptor.FileDescriptorProto, service *descriptor.ServiceDescriptorProto) {

	// log.Print("error:", file.Service, file.GetPackage())
	// log.Print("error:", file.MessageType[0].Field[0].Type)

	fieldDic := make(map[string][]*descriptor.FieldDescriptorProto)
	for _, t := range file.MessageType {
		fieldDic[*t.Name] = t.Field
	}

	servName := serviceName(service) + name + "Client"

	t.P(`class `, servName, ` {`)
	t.P(`private:
  string base_url;

public:`)
	t.P(`  `, servName, `(string u) : base_url(u) {};`)
	t.P()

	for _, method := range service.Method {
		methName := methodName(method)
		inputType := t.goTypeName(method.GetInputType())
		outputType := t.goTypeName(method.GetOutputType())

		t.P(`  `, outputType, ` `, methName, `(`, inputType, ` in) {`)

		// In
		t.P(`    JSON body = json::Object();`)
		for _, f := range fieldDic[inputType] {
			t.P(`    body["`, *f.JsonName, `"] = in.`, *f.Name, `();`)
		}
		t.P()

		// Request URL
		url := `/twirp/` + file.GetPackage() + `.` + serviceName(service) + `/` + methName
		t.P(`    http::Request request(base_url + "`, url, `");`)
		t.P()

		t.P(`    // Send a post request
    http::Response response = request.send("POST", body.dump(), { "Content-Type:application/json" });
    std::string res_str(response.body.begin(), response.body.end());
    JSON res = JSON::Load(res_str);`)
		t.P()

		// Out
		t.P(`    `, outputType, ` out;`)
		for _, f := range fieldDic[outputType] {
			t.P(`    out.set_`, *f.Name, `(res["`, *f.JsonName, `"].`, JSONTypeToConv(f), `());`)
		}
		t.P()

		t.P(`    return out;`)
		t.P(`  }`)
		t.P()
	}

	t.P(`};`)
}

// JSONTypeToConv ...
func JSONTypeToConv(field *descriptor.FieldDescriptorProto) string {
	switch JSONType(field) {
	case "float":
		return "ToFloat"
	case "bool":
		return "ToBool"
	case "int":
		return "ToInt"
	case "string":
		return "ToString"
	case "uint16":
		return "ToHost16"
	case "uint32":
		return "ToHost32"
	case "uint64":
		return "ToHost64"
	default:
		gen.Fail("unknown type for", field.GetName())
		return ""
	}
}

// JSONType returns a string representing the type name
func JSONType(field *descriptor.FieldDescriptorProto) (typ string) {
	switch *field.Type {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		typ = "float"
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		typ = "float"
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		typ = "int"
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		typ = "uint64"
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		typ = "int"
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		typ = "uint32"
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		typ = "uint64"
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		typ = "uint32"
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		typ = "bool"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		typ = "string"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		typ = "int"
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		typ = "int"
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		typ = "int"
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		typ = "int"
	default:
		gen.Fail("unknown type for", field.GetName())
	}

	if isRepeated(field) {
		typ = "[]" + typ
	}
	// else if needsStar(*field.Type) {
	// typ = "*" + typ
	// }

	return
}

// func needsStar(typ descriptor.FieldDescriptorProto_Type) bool {
// 	switch typ {
// 	case descriptor.FieldDescriptorProto_TYPE_GROUP:
// 		return false
// 	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
// 		return false
// 	case descriptor.FieldDescriptorProto_TYPE_BYTES:
// 		return false
// 	}
// 	return true
// }

// Is this field repeated?
func isRepeated(field *descriptor.FieldDescriptorProto) bool {
	return field.Label != nil && *field.Label == descriptor.FieldDescriptorProto_LABEL_REPEATED
}

// Given a protobuf name for a Message, return the Go name we will use for that
// type, including its package prefix.
func (t *twirp) goTypeName(protoName string) string {
	def := t.reg.MessageDefinition(protoName)
	if def == nil {
		gen.Fail("could not find message for", protoName)
	}

	var prefix string

	var name string
	for _, parent := range def.Lineage() {
		name += parent.Descriptor.GetName() + "_"
	}
	name += def.Descriptor.GetName()
	return prefix + name
}

func serviceName(service *descriptor.ServiceDescriptorProto) string {
	return stringutils.CamelCase(service.GetName())
}

func methodName(method *descriptor.MethodDescriptorProto) string {
	return stringutils.CamelCase(method.GetName())
}
